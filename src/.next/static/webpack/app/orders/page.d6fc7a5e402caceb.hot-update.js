"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/orders/page",{

/***/ "(app-pages-browser)/./services/ui/orderService.ts":
/*!*************************************!*\
  !*** ./services/ui/orderService.ts ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createProductionOrder: function() { return /* binding */ createProductionOrder; },\n/* harmony export */   fetchOrderDetail: function() { return /* binding */ fetchOrderDetail; },\n/* harmony export */   fetchOrdersList: function() { return /* binding */ fetchOrdersList; }\n/* harmony export */ });\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! uuid */ \"(app-pages-browser)/../node_modules/uuid/dist/esm-browser/v4.js\");\n/* harmony import */ var _shared_schemas__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/schemas */ \"(app-pages-browser)/./shared/schemas.ts\");\n/* harmony import */ var _data_dexie_workOrderRepositoryDexie__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../data/dexie/workOrderRepositoryDexie */ \"(app-pages-browser)/./data/dexie/workOrderRepositoryDexie.ts\");\n/* harmony import */ var _data_dexie_eventRepositoryDexie__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../data/dexie/eventRepositoryDexie */ \"(app-pages-browser)/./data/dexie/eventRepositoryDexie.ts\");\n/* harmony import */ var _data_dexie_lotRepositoryDexie__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../data/dexie/lotRepositoryDexie */ \"(app-pages-browser)/./data/dexie/lotRepositoryDexie.ts\");\n/* harmony import */ var _data_dexie_productRepositoryDexie__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../data/dexie/productRepositoryDexie */ \"(app-pages-browser)/./data/dexie/productRepositoryDexie.ts\");\n/* harmony import */ var _data_dexie_operationRepositoryDexie__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../data/dexie/operationRepositoryDexie */ \"(app-pages-browser)/./data/dexie/operationRepositoryDexie.ts\");\n/* harmony import */ var _domain_services_aggregation__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../domain/services/aggregation */ \"(app-pages-browser)/./domain/services/aggregation.ts\");\n/* harmony import */ var _domain_services_lotProgress__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../domain/services/lotProgress */ \"(app-pages-browser)/./domain/services/lotProgress.ts\");\n/* harmony import */ var _productService__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./productService */ \"(app-pages-browser)/./services/ui/productService.ts\");\n/* harmony import */ var _routingService__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./routingService */ \"(app-pages-browser)/./services/ui/routingService.ts\");\n/* harmony import */ var _operationService__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./operationService */ \"(app-pages-browser)/./services/ui/operationService.ts\");\n/* harmony import */ var _lotService__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./lotService */ \"(app-pages-browser)/./services/ui/lotService.ts\");\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst orderRepo = new _data_dexie_workOrderRepositoryDexie__WEBPACK_IMPORTED_MODULE_1__.ProductionOrderRepositoryDexie();\nconst eventRepo = new _data_dexie_eventRepositoryDexie__WEBPACK_IMPORTED_MODULE_2__.EventRepositoryDexie();\nconst lotRepo = new _data_dexie_lotRepositoryDexie__WEBPACK_IMPORTED_MODULE_3__.LotRepositoryDexie();\nconst productRepo = new _data_dexie_productRepositoryDexie__WEBPACK_IMPORTED_MODULE_4__.ProductRepositoryDexie();\nconst operationRepo = new _data_dexie_operationRepositoryDexie__WEBPACK_IMPORTED_MODULE_5__.OperationRepositoryDexie();\nasync function createProductionOrder(input) {\n    // Validate lotSize if trackingMode != piece\n    if (input.trackingMode !== \"piece\" && (!input.lotSize || input.lotSize <= 0 || input.lotSize > input.quantityRequested)) {\n        throw new Error(\"Lot size is required and must be greater than 0 and less than or equal to target pieces\");\n    }\n    // a) Fetch product by id\n    const product = await (0,_productService__WEBPACK_IMPORTED_MODULE_8__.fetchProductById)(input.productId);\n    if (!product) {\n        throw new Error(\"Product not found\");\n    }\n    // b) Validate that product.activeRoutingVersionId exists\n    if (!product.activeRoutingVersionId) {\n        throw new Error(\"Publish a routing version first\");\n    }\n    // c) Fetch routingVersion active + routingOperations\n    const routingVersion = await (0,_routingService__WEBPACK_IMPORTED_MODULE_9__.fetchRoutingVersionById)(product.activeRoutingVersionId);\n    if (!routingVersion) {\n        throw new Error(\"Active routing version not found\");\n    }\n    if (routingVersion.isDraft) {\n        throw new Error(\"Active routing version is still a draft. Publish it first.\");\n    }\n    const routingOperations = await (0,_routingService__WEBPACK_IMPORTED_MODULE_9__.fetchRoutingOperationsByVersion)(routingVersion.id);\n    if (routingOperations.length === 0) {\n        throw new Error(\"Active routing version has no operations\");\n    }\n    // d) Build routingSnapshot with full operation details\n    const operationsWithDetails = await Promise.all(routingOperations.map(async (ro)=>{\n        const operation = await (0,_operationService__WEBPACK_IMPORTED_MODULE_10__.fetchOperationById)(ro.operationId);\n        if (!operation) {\n            throw new Error(\"Operation \".concat(ro.operationId, \" not found\"));\n        }\n        var _ro_standardMinutesOverride;\n        const standardMinutes = (_ro_standardMinutesOverride = ro.standardMinutesOverride) !== null && _ro_standardMinutesOverride !== void 0 ? _ro_standardMinutesOverride : operation.durationMinutes;\n        var _operation_qualityGate;\n        return {\n            operationId: ro.operationId,\n            sequence: ro.sequence,\n            standardMinutes,\n            operationName: operation.name,\n            qualityGate: (_operation_qualityGate = operation.qualityGate) !== null && _operation_qualityGate !== void 0 ? _operation_qualityGate : false,\n            workCenterId: ro.workCenterIdOverride\n        };\n    }));\n    // Sort by sequence to ensure correct order\n    operationsWithDetails.sort((a, b)=>a.sequence - b.sequence);\n    const routingSnapshot = {\n        id: routingVersion.id,\n        productId: product.id,\n        operations: operationsWithDetails\n    };\n    // e) Create ProductionOrder\n    const workshopId = (0,uuid__WEBPACK_IMPORTED_MODULE_12__[\"default\"])(); // Generate new workshopId for this order\n    const orderId = (0,uuid__WEBPACK_IMPORTED_MODULE_12__[\"default\"])();\n    const order = _shared_schemas__WEBPACK_IMPORTED_MODULE_0__.ProductionOrderSchema.parse({\n        id: orderId,\n        productId: input.productId,\n        quantityRequested: input.quantityRequested,\n        workshopId,\n        routingVersionSnapshot: routingSnapshot,\n        trackingMode: input.trackingMode\n    });\n    // f) Persist via repository\n    await orderRepo.add(order);\n    // g) Create lots if trackingMode != piece\n    if (input.trackingMode !== \"piece\" && input.lotSize) {\n        const lotCount = Math.ceil(input.quantityRequested / input.lotSize);\n        const lots = [];\n        const now = new Date().toISOString();\n        for(let i = 1; i <= lotCount; i++){\n            const isLastLot = i === lotCount;\n            const plannedPieces = isLastLot ? input.quantityRequested - (lotCount - 1) * input.lotSize // Last lot gets remainder\n             : input.lotSize;\n            const lot = _shared_schemas__WEBPACK_IMPORTED_MODULE_0__.LotSchema.parse({\n                id: (0,uuid__WEBPACK_IMPORTED_MODULE_12__[\"default\"])(),\n                orderId: orderId,\n                lotNumber: i,\n                plannedPieces,\n                createdAt: now\n            });\n            lots.push(lot);\n        }\n        await lotRepo.createMany(lots);\n    }\n    // Create initial WorkEvent (ProductionOrderCreated)\n    const event = _shared_schemas__WEBPACK_IMPORTED_MODULE_0__.WorkEventSchema.parse({\n        id: (0,uuid__WEBPACK_IMPORTED_MODULE_12__[\"default\"])(),\n        type: \"ProductionOrderCreated\",\n        aggregateId: order.id,\n        workshopId: order.workshopId,\n        timestamp: new Date().toISOString(),\n        payload: {\n            quantity: order.quantityRequested\n        },\n        schemaVersion: 1\n    });\n    await eventRepo.append(event);\n    // Enqueue to outbox\n    const outboxRepo = new _data_dexie_eventRepositoryDexie__WEBPACK_IMPORTED_MODULE_2__.OutboxRepositoryDexie();\n    const outboxEvent = _shared_schemas__WEBPACK_IMPORTED_MODULE_0__.OutboxEventSchema.parse({\n        ...event,\n        status: \"pending\"\n    });\n    await outboxRepo.enqueue(outboxEvent);\n    return order;\n}\nasync function fetchOrdersList() {\n    const orders = await orderRepo.listAll();\n    // Note: currently we don't have multi-workshop listing; listing all orders for demo purposes\n    // Fetch all products in one batch to avoid N+1\n    const productIds = [\n        ...new Set(orders.map((o)=>o.productId))\n    ];\n    const products = await Promise.all(productIds.map((id)=>productRepo.getById(id)));\n    const productMap = new Map(products.filter((p)=>p !== undefined).map((p)=>[\n            p.id,\n            p\n        ]));\n    // Batch load all events for all orders in one query (avoid N+1)\n    const orderIds = orders.map((o)=>o.id);\n    const allEvents = await eventRepo.listByAggregateIds(orderIds);\n    // Group events by aggregateId (orderId)\n    const eventsByOrderId = new Map();\n    for (const event of allEvents){\n        var _eventsByOrderId_get;\n        const existing = (_eventsByOrderId_get = eventsByOrderId.get(event.aggregateId)) !== null && _eventsByOrderId_get !== void 0 ? _eventsByOrderId_get : [];\n        existing.push(event);\n        eventsByOrderId.set(event.aggregateId, existing);\n    }\n    // Compute progress for each order using pre-loaded events\n    const vms = orders.map((o)=>{\n        var _eventsByOrderId_get;\n        const events = (_eventsByOrderId_get = eventsByOrderId.get(o.id)) !== null && _eventsByOrderId_get !== void 0 ? _eventsByOrderId_get : [];\n        var _o_routingVersionSnapshot;\n        const progress = (0,_domain_services_aggregation__WEBPACK_IMPORTED_MODULE_6__.computeOrderProgressFromEvents)({\n            id: o.id,\n            quantityRequested: o.quantityRequested\n        }, (_o_routingVersionSnapshot = o.routingVersionSnapshot) !== null && _o_routingVersionSnapshot !== void 0 ? _o_routingVersionSnapshot : {\n            id: \"\",\n            operations: []\n        }, events);\n        const product = productMap.get(o.productId);\n        var _product_name, _o_trackingMode;\n        return {\n            orderId: o.id,\n            productId: o.productId,\n            productName: (_product_name = product === null || product === void 0 ? void 0 : product.name) !== null && _product_name !== void 0 ? _product_name : \"Product (\".concat(o.productId.slice(0, 8), \"...)\"),\n            productSku: product === null || product === void 0 ? void 0 : product.sku,\n            targetPieces: progress.targetPieces,\n            completedPieces: progress.completedPieces,\n            wipPieces: progress.wipPieces,\n            processedPieces: progress.processedPieces,\n            scrapPieces: progress.scrapPieces,\n            completionPercent: progress.completionPercent,\n            trackingMode: (_o_trackingMode = o.trackingMode) !== null && _o_trackingMode !== void 0 ? _o_trackingMode : \"piece\",\n            updatedAt: undefined\n        };\n    });\n    return vms;\n}\nasync function fetchOrderDetail(orderId) {\n    const order = await orderRepo.getById(orderId);\n    if (!order) return null;\n    const events = await eventRepo.listByAggregate(orderId);\n    // Safe-validate routing snapshot\n    const snapshotParseResult = RoutingSnapshotSchema.safeParse(order.routingVersionSnapshot);\n    if (!snapshotParseResult.success) {\n        // Invalid snapshot - return error state (UI will handle gracefully)\n        return {\n            order,\n            stages: [],\n            processedPieces: 0,\n            completedPieces: 0,\n            wipPieces: 0,\n            completionPercent: 0,\n            error: \"Invalid routing snapshot\"\n        };\n    }\n    const routingSnapshot = snapshotParseResult.data;\n    // Compute order progress to get correct completionPercent\n    const progress = (0,_domain_services_aggregation__WEBPACK_IMPORTED_MODULE_6__.computeOrderProgressFromEvents)({\n        id: order.id,\n        quantityRequested: order.quantityRequested\n    }, routingSnapshot, events);\n    const stages = (0,_domain_services_aggregation__WEBPACK_IMPORTED_MODULE_6__.computeStageTotalsFromEvents)(routingSnapshot, events);\n    // Fetch operation names to enrich stages\n    const operationIds = [\n        ...new Set(stages.map((s)=>s.operationId))\n    ];\n    const operations = await Promise.all(operationIds.map((id)=>operationRepo.getById(id)));\n    const operationMap = new Map(operations.filter((op)=>op !== undefined).map((op)=>[\n            op.id,\n            op\n        ]));\n    const enrichedStages = stages.map((stage)=>{\n        const operation = operationMap.get(stage.operationId);\n        return {\n            ...stage,\n            operationName: operation === null || operation === void 0 ? void 0 : operation.name\n        };\n    });\n    // Fetch lots if trackingMode != piece and compute progress\n    let lots = undefined;\n    if (order.trackingMode && order.trackingMode !== \"piece\") {\n        const orderLots = await (0,_lotService__WEBPACK_IMPORTED_MODULE_11__.getLotsForOrder)(order.id);\n        if (orderLots.length > 0) {\n            // Build routing operations from snapshot for lot progress calculation\n            const routingOps = routingSnapshot.operations.map((op)=>({\n                    operationId: op.operationId,\n                    sequence: op.sequence\n                }));\n            // Compute lot progress from events\n            const lotProgressMap = (0,_domain_services_lotProgress__WEBPACK_IMPORTED_MODULE_7__.computeLotProgressFromEvents)(orderLots.map((lot)=>({\n                    id: lot.id,\n                    lotNumber: lot.lotNumber,\n                    plannedPieces: lot.plannedPieces\n                })), routingOps, events);\n            // Map to VM format, sorted by lotNumber\n            lots = orderLots.map((lot)=>{\n                const progress = lotProgressMap.get(lot.id);\n                if (!progress) {\n                    // Fallback if progress not found (shouldn't happen)\n                    return {\n                        id: lot.id,\n                        lotNumber: lot.lotNumber,\n                        plannedPieces: lot.plannedPieces,\n                        donePieces: 0,\n                        remainingPieces: lot.plannedPieces,\n                        status: \"not_started\",\n                        overProduced: false,\n                        wipPieces: 0\n                    };\n                }\n                return {\n                    id: progress.lotId,\n                    lotNumber: progress.lotNumber,\n                    plannedPieces: progress.plannedPieces,\n                    donePieces: progress.donePieces,\n                    remainingPieces: progress.remainingPieces,\n                    status: progress.status,\n                    overProduced: progress.overProduced,\n                    wipPieces: progress.wipPieces\n                };\n            }).sort((a, b)=>a.lotNumber - b.lotNumber);\n        }\n    }\n    return {\n        order,\n        stages: enrichedStages,\n        processedPieces: progress.processedPieces,\n        completedPieces: progress.completedPieces,\n        wipPieces: progress.wipPieces,\n        completionPercent: progress.completionPercent,\n        avgStageProgress: progress.avgStageProgress,\n        lots\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NlcnZpY2VzL3VpL29yZGVyU2VydmljZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQW9DO0FBQzhGO0FBQ3ZDO0FBQ1M7QUFDM0I7QUFDUTtBQUNJO0FBQzRCO0FBQ2hDO0FBQzdCO0FBQ3dDO0FBQ3BDO0FBQ1Q7QUFFL0MsTUFBTW9CLFlBQVksSUFBSWQsZ0dBQThCQTtBQUNwRCxNQUFNZSxZQUFZLElBQUlkLGtGQUFvQkE7QUFDMUMsTUFBTWUsVUFBVSxJQUFJYiw4RUFBa0JBO0FBQ3RDLE1BQU1jLGNBQWMsSUFBSWIsc0ZBQXNCQTtBQUM5QyxNQUFNYyxnQkFBZ0IsSUFBSWIsMEZBQXdCQTtBQXlCM0MsZUFBZWMsc0JBQXNCQyxLQUFpQztJQUMzRSw0Q0FBNEM7SUFDNUMsSUFBSUEsTUFBTUMsWUFBWSxLQUFLLFdBQVksRUFBQ0QsTUFBTUUsT0FBTyxJQUFJRixNQUFNRSxPQUFPLElBQUksS0FBS0YsTUFBTUUsT0FBTyxHQUFHRixNQUFNRyxpQkFBaUIsR0FBRztRQUN2SCxNQUFNLElBQUlDLE1BQU07SUFDbEI7SUFDQSx5QkFBeUI7SUFDekIsTUFBTUMsVUFBVSxNQUFNaEIsaUVBQWdCQSxDQUFDVyxNQUFNTSxTQUFTO0lBQ3RELElBQUksQ0FBQ0QsU0FBUztRQUNaLE1BQU0sSUFBSUQsTUFBTTtJQUNsQjtJQUVBLHlEQUF5RDtJQUN6RCxJQUFJLENBQUNDLFFBQVFFLHNCQUFzQixFQUFFO1FBQ25DLE1BQU0sSUFBSUgsTUFBTTtJQUNsQjtJQUVBLHFEQUFxRDtJQUNyRCxNQUFNSSxpQkFBaUIsTUFBTWxCLHdFQUF1QkEsQ0FBQ2UsUUFBUUUsc0JBQXNCO0lBQ25GLElBQUksQ0FBQ0MsZ0JBQWdCO1FBQ25CLE1BQU0sSUFBSUosTUFBTTtJQUNsQjtJQUNBLElBQUlJLGVBQWVDLE9BQU8sRUFBRTtRQUMxQixNQUFNLElBQUlMLE1BQU07SUFDbEI7SUFFQSxNQUFNTSxvQkFBb0IsTUFBTW5CLGdGQUErQkEsQ0FBQ2lCLGVBQWVHLEVBQUU7SUFDakYsSUFBSUQsa0JBQWtCRSxNQUFNLEtBQUssR0FBRztRQUNsQyxNQUFNLElBQUlSLE1BQU07SUFDbEI7SUFFQSx1REFBdUQ7SUFDdkQsTUFBTVMsd0JBQXdCLE1BQU1DLFFBQVFDLEdBQUcsQ0FDN0NMLGtCQUFrQk0sR0FBRyxDQUFDLE9BQU9DO1FBQzNCLE1BQU1DLFlBQVksTUFBTTFCLHNFQUFrQkEsQ0FBQ3lCLEdBQUdFLFdBQVc7UUFDekQsSUFBSSxDQUFDRCxXQUFXO1lBQ2QsTUFBTSxJQUFJZCxNQUFNLGFBQTRCLE9BQWZhLEdBQUdFLFdBQVcsRUFBQztRQUM5QztZQUV3QkY7UUFBeEIsTUFBTUcsa0JBQWtCSCxDQUFBQSw4QkFBQUEsR0FBR0ksdUJBQXVCLGNBQTFCSix5Q0FBQUEsOEJBQThCQyxVQUFVSSxlQUFlO1lBT2hFSjtRQUxmLE9BQU87WUFDTEMsYUFBYUYsR0FBR0UsV0FBVztZQUMzQkksVUFBVU4sR0FBR00sUUFBUTtZQUNyQkg7WUFDQUksZUFBZU4sVUFBVU8sSUFBSTtZQUM3QkMsYUFBYVIsQ0FBQUEseUJBQUFBLFVBQVVRLFdBQVcsY0FBckJSLG9DQUFBQSx5QkFBeUI7WUFDdENTLGNBQWNWLEdBQUdXLG9CQUFvQjtRQUN2QztJQUNGO0lBR0YsMkNBQTJDO0lBQzNDZixzQkFBc0JnQixJQUFJLENBQUMsQ0FBQ0MsR0FBR0MsSUFBTUQsRUFBRVAsUUFBUSxHQUFHUSxFQUFFUixRQUFRO0lBRTVELE1BQU1TLGtCQUFtQztRQUN2Q3JCLElBQUlILGVBQWVHLEVBQUU7UUFDckJMLFdBQVdELFFBQVFNLEVBQUU7UUFDckJzQixZQUFZcEI7SUFDZDtJQUVBLDRCQUE0QjtJQUM1QixNQUFNcUIsYUFBYTNELGlEQUFNQSxJQUFJLHlDQUF5QztJQUN0RSxNQUFNNEQsVUFBVTVELGlEQUFNQTtJQUN0QixNQUFNNkQsUUFBUTVELGtFQUFxQkEsQ0FBQzZELEtBQUssQ0FBQztRQUN4QzFCLElBQUl3QjtRQUNKN0IsV0FBV04sTUFBTU0sU0FBUztRQUMxQkgsbUJBQW1CSCxNQUFNRyxpQkFBaUI7UUFDMUMrQjtRQUNBSSx3QkFBd0JOO1FBQ3hCL0IsY0FBY0QsTUFBTUMsWUFBWTtJQUNsQztJQUVBLDRCQUE0QjtJQUM1QixNQUFNUCxVQUFVNkMsR0FBRyxDQUFDSDtJQUVwQiwwQ0FBMEM7SUFDMUMsSUFBSXBDLE1BQU1DLFlBQVksS0FBSyxXQUFXRCxNQUFNRSxPQUFPLEVBQUU7UUFDbkQsTUFBTXNDLFdBQVdDLEtBQUtDLElBQUksQ0FBQzFDLE1BQU1HLGlCQUFpQixHQUFHSCxNQUFNRSxPQUFPO1FBQ2xFLE1BQU15QyxPQUFjLEVBQUU7UUFDdEIsTUFBTUMsTUFBTSxJQUFJQyxPQUFPQyxXQUFXO1FBRWxDLElBQUssSUFBSUMsSUFBSSxHQUFHQSxLQUFLUCxVQUFVTyxJQUFLO1lBQ2xDLE1BQU1DLFlBQVlELE1BQU1QO1lBQ3hCLE1BQU1TLGdCQUFnQkQsWUFDbEJoRCxNQUFNRyxpQkFBaUIsR0FBRyxDQUFDcUMsV0FBVyxLQUFLeEMsTUFBTUUsT0FBTyxDQUFDLDBCQUEwQjtlQUNuRkYsTUFBTUUsT0FBTztZQUVqQixNQUFNZ0QsTUFBTXZFLHNEQUFTQSxDQUFDMEQsS0FBSyxDQUFDO2dCQUMxQjFCLElBQUlwQyxpREFBTUE7Z0JBQ1Y0RCxTQUFTQTtnQkFDVGdCLFdBQVdKO2dCQUNYRTtnQkFDQUcsV0FBV1I7WUFDYjtZQUNBRCxLQUFLVSxJQUFJLENBQUNIO1FBQ1o7UUFFQSxNQUFNdEQsUUFBUTBELFVBQVUsQ0FBQ1g7SUFDM0I7SUFFQSxvREFBb0Q7SUFDcEQsTUFBTVksUUFBUTlFLDREQUFlQSxDQUFDNEQsS0FBSyxDQUFDO1FBQ2xDMUIsSUFBSXBDLGlEQUFNQTtRQUNWaUYsTUFBTTtRQUNOQyxhQUFhckIsTUFBTXpCLEVBQUU7UUFDckJ1QixZQUFZRSxNQUFNRixVQUFVO1FBQzVCd0IsV0FBVyxJQUFJYixPQUFPQyxXQUFXO1FBQ2pDYSxTQUFTO1lBQUVDLFVBQVV4QixNQUFNakMsaUJBQWlCO1FBQUM7UUFDN0MwRCxlQUFlO0lBQ2pCO0lBQ0EsTUFBTWxFLFVBQVVtRSxNQUFNLENBQUNQO0lBRXZCLG9CQUFvQjtJQUNwQixNQUFNUSxhQUFhLElBQUlqRixtRkFBcUJBO0lBQzVDLE1BQU1rRixjQUFjdEYsOERBQWlCQSxDQUFDMkQsS0FBSyxDQUFDO1FBQzFDLEdBQUdrQixLQUFLO1FBQ1JVLFFBQVE7SUFDVjtJQUNBLE1BQU1GLFdBQVdHLE9BQU8sQ0FBQ0Y7SUFFekIsT0FBTzVCO0FBQ1Q7QUFpQk8sZUFBZStCO0lBQ3BCLE1BQU1DLFNBQVMsTUFBTTFFLFVBQVUyRSxPQUFPO0lBQ3RDLDZGQUE2RjtJQUU3RiwrQ0FBK0M7SUFDL0MsTUFBTUMsYUFBYTtXQUFJLElBQUlDLElBQUlILE9BQU9wRCxHQUFHLENBQUMsQ0FBQ3dELElBQU1BLEVBQUVsRSxTQUFTO0tBQUc7SUFDL0QsTUFBTW1FLFdBQVcsTUFBTTNELFFBQVFDLEdBQUcsQ0FBQ3VELFdBQVd0RCxHQUFHLENBQUMsQ0FBQ0wsS0FBT2QsWUFBWTZFLE9BQU8sQ0FBQy9EO0lBQzlFLE1BQU1nRSxhQUFhLElBQUlDLElBQUlILFNBQVNJLE1BQU0sQ0FBQyxDQUFDQyxJQUFrQ0EsTUFBTUMsV0FBVy9ELEdBQUcsQ0FBQyxDQUFDOEQsSUFBTTtZQUFDQSxFQUFFbkUsRUFBRTtZQUFFbUU7U0FBRTtJQUVuSCxnRUFBZ0U7SUFDaEUsTUFBTUUsV0FBV1osT0FBT3BELEdBQUcsQ0FBQyxDQUFDd0QsSUFBTUEsRUFBRTdELEVBQUU7SUFDdkMsTUFBTXNFLFlBQVksTUFBTXRGLFVBQVV1RixrQkFBa0IsQ0FBQ0Y7SUFFckQsd0NBQXdDO0lBQ3hDLE1BQU1HLGtCQUFrQixJQUFJUDtJQUM1QixLQUFLLE1BQU1yQixTQUFTMEIsVUFBVztZQUNaRTtRQUFqQixNQUFNQyxXQUFXRCxDQUFBQSx1QkFBQUEsZ0JBQWdCRSxHQUFHLENBQUM5QixNQUFNRSxXQUFXLGVBQXJDMEIsa0NBQUFBLHVCQUEwQyxFQUFFO1FBQzdEQyxTQUFTL0IsSUFBSSxDQUFDRTtRQUNkNEIsZ0JBQWdCRyxHQUFHLENBQUMvQixNQUFNRSxXQUFXLEVBQUUyQjtJQUN6QztJQUVBLDBEQUEwRDtJQUMxRCxNQUFNRyxNQUFNbkIsT0FBT3BELEdBQUcsQ0FBQyxDQUFDd0Q7WUFDUFc7UUFBZixNQUFNSyxTQUFTTCxDQUFBQSx1QkFBQUEsZ0JBQWdCRSxHQUFHLENBQUNiLEVBQUU3RCxFQUFFLGVBQXhCd0Usa0NBQUFBLHVCQUE2QixFQUFFO1lBQ3lEWDtRQUF2RyxNQUFNaUIsV0FBV3ZHLDRGQUE4QkEsQ0FBQztZQUFFeUIsSUFBSTZELEVBQUU3RCxFQUFFO1lBQUVSLG1CQUFtQnFFLEVBQUVyRSxpQkFBaUI7UUFBQyxHQUFHLENBQUNxRSw0QkFBQUEsRUFBRWxDLHNCQUFzQixjQUF4QmtDLHVDQUFBQSw0QkFBb0M7WUFBRTdELElBQUk7WUFBSXNCLFlBQVksRUFBRTtRQUFDLEdBQUd1RDtRQUN2SyxNQUFNbkYsVUFBVXNFLFdBQVdVLEdBQUcsQ0FBQ2IsRUFBRWxFLFNBQVM7WUFJM0JELGVBUUNtRTtRQVhoQixPQUFPO1lBQ0xyQyxTQUFTcUMsRUFBRTdELEVBQUU7WUFDYkwsV0FBV2tFLEVBQUVsRSxTQUFTO1lBQ3RCb0YsYUFBYXJGLENBQUFBLGdCQUFBQSxvQkFBQUEsOEJBQUFBLFFBQVNvQixJQUFJLGNBQWJwQiwyQkFBQUEsZ0JBQWlCLFlBQW9DLE9BQXhCbUUsRUFBRWxFLFNBQVMsQ0FBQ3FGLEtBQUssQ0FBQyxHQUFHLElBQUc7WUFDbEVDLFVBQVUsRUFBRXZGLG9CQUFBQSw4QkFBQUEsUUFBU3dGLEdBQUc7WUFDeEJDLGNBQWNMLFNBQVNLLFlBQVk7WUFDbkNDLGlCQUFpQk4sU0FBU00sZUFBZTtZQUN6Q0MsV0FBV1AsU0FBU08sU0FBUztZQUM3QkMsaUJBQWlCUixTQUFTUSxlQUFlO1lBQ3pDQyxhQUFhVCxTQUFTUyxXQUFXO1lBQ2pDQyxtQkFBbUJWLFNBQVNVLGlCQUFpQjtZQUM3Q2xHLGNBQWN1RSxDQUFBQSxrQkFBQUEsRUFBRXZFLFlBQVksY0FBZHVFLDZCQUFBQSxrQkFBa0I7WUFDaEM0QixXQUFXckI7UUFDYjtJQUNGO0lBQ0EsT0FBT1E7QUFDVDtBQThCTyxlQUFlYyxpQkFBaUJsRSxPQUFlO0lBQ3BELE1BQU1DLFFBQVEsTUFBTTFDLFVBQVVnRixPQUFPLENBQUN2QztJQUN0QyxJQUFJLENBQUNDLE9BQU8sT0FBTztJQUNuQixNQUFNb0QsU0FBUyxNQUFNN0YsVUFBVTJHLGVBQWUsQ0FBQ25FO0lBRS9DLGlDQUFpQztJQUNqQyxNQUFNb0Usc0JBQXNCQyxzQkFBc0JDLFNBQVMsQ0FBQ3JFLE1BQU1FLHNCQUFzQjtJQUN4RixJQUFJLENBQUNpRSxvQkFBb0JHLE9BQU8sRUFBRTtRQUNoQyxvRUFBb0U7UUFDcEUsT0FBTztZQUNMdEU7WUFDQXVFLFFBQVEsRUFBRTtZQUNWVixpQkFBaUI7WUFDakJGLGlCQUFpQjtZQUNqQkMsV0FBVztZQUNYRyxtQkFBbUI7WUFDbkJTLE9BQU87UUFDVDtJQUNGO0lBQ0EsTUFBTTVFLGtCQUFrQnVFLG9CQUFvQk0sSUFBSTtJQUVoRCwwREFBMEQ7SUFDMUQsTUFBTXBCLFdBQVd2Ryw0RkFBOEJBLENBQzdDO1FBQUV5QixJQUFJeUIsTUFBTXpCLEVBQUU7UUFBRVIsbUJBQW1CaUMsTUFBTWpDLGlCQUFpQjtJQUFDLEdBQzNENkIsaUJBQ0F3RDtJQUdGLE1BQU1tQixTQUFTeEgsMEZBQTRCQSxDQUFDNkMsaUJBQWlCd0Q7SUFFN0QseUNBQXlDO0lBQ3pDLE1BQU1zQixlQUFlO1dBQUksSUFBSXZDLElBQUlvQyxPQUFPM0YsR0FBRyxDQUFDLENBQUMrRixJQUFNQSxFQUFFNUYsV0FBVztLQUFHO0lBQ25FLE1BQU1jLGFBQWEsTUFBTW5CLFFBQVFDLEdBQUcsQ0FBQytGLGFBQWE5RixHQUFHLENBQUMsQ0FBQ0wsS0FBT2IsY0FBYzRFLE9BQU8sQ0FBQy9EO0lBQ3BGLE1BQU1xRyxlQUFlLElBQUlwQyxJQUFJM0MsV0FBVzRDLE1BQU0sQ0FBQyxDQUFDb0MsS0FBcUNBLE9BQU9sQyxXQUFXL0QsR0FBRyxDQUFDLENBQUNpRyxLQUFPO1lBQUNBLEdBQUd0RyxFQUFFO1lBQUVzRztTQUFHO0lBRTlILE1BQU1DLGlCQUFpQlAsT0FBTzNGLEdBQUcsQ0FBQyxDQUFDbUc7UUFDakMsTUFBTWpHLFlBQVk4RixhQUFhM0IsR0FBRyxDQUFDOEIsTUFBTWhHLFdBQVc7UUFDcEQsT0FBTztZQUNMLEdBQUdnRyxLQUFLO1lBQ1IzRixhQUFhLEVBQUVOLHNCQUFBQSxnQ0FBQUEsVUFBV08sSUFBSTtRQUNoQztJQUNGO0lBRUEsMkRBQTJEO0lBQzNELElBQUlrQixPQUE4Qm9DO0lBQ2xDLElBQUkzQyxNQUFNbkMsWUFBWSxJQUFJbUMsTUFBTW5DLFlBQVksS0FBSyxTQUFTO1FBQ3hELE1BQU1tSCxZQUFZLE1BQU0zSCw2REFBZUEsQ0FBQzJDLE1BQU16QixFQUFFO1FBQ2hELElBQUl5RyxVQUFVeEcsTUFBTSxHQUFHLEdBQUc7WUFDeEIsc0VBQXNFO1lBQ3RFLE1BQU15RyxhQUFhckYsZ0JBQWdCQyxVQUFVLENBQUNqQixHQUFHLENBQUMsQ0FBQ2lHLEtBQW1EO29CQUNwRzlGLGFBQWE4RixHQUFHOUYsV0FBVztvQkFDM0JJLFVBQVUwRixHQUFHMUYsUUFBUTtnQkFDdkI7WUFFQSxtQ0FBbUM7WUFDbkMsTUFBTStGLGlCQUFpQmxJLDBGQUE0QkEsQ0FDakRnSSxVQUFVcEcsR0FBRyxDQUFDLENBQUNrQyxNQUFTO29CQUN0QnZDLElBQUl1QyxJQUFJdkMsRUFBRTtvQkFDVndDLFdBQVdELElBQUlDLFNBQVM7b0JBQ3hCRixlQUFlQyxJQUFJRCxhQUFhO2dCQUNsQyxLQUNBb0UsWUFDQTdCO1lBR0Ysd0NBQXdDO1lBQ3hDN0MsT0FBT3lFLFVBQ0pwRyxHQUFHLENBQUMsQ0FBQ2tDO2dCQUNKLE1BQU11QyxXQUFXNkIsZUFBZWpDLEdBQUcsQ0FBQ25DLElBQUl2QyxFQUFFO2dCQUMxQyxJQUFJLENBQUM4RSxVQUFVO29CQUNiLG9EQUFvRDtvQkFDcEQsT0FBTzt3QkFDTDlFLElBQUl1QyxJQUFJdkMsRUFBRTt3QkFDVndDLFdBQVdELElBQUlDLFNBQVM7d0JBQ3hCRixlQUFlQyxJQUFJRCxhQUFhO3dCQUNoQ3NFLFlBQVk7d0JBQ1pDLGlCQUFpQnRFLElBQUlELGFBQWE7d0JBQ2xDZ0IsUUFBUTt3QkFDUndELGNBQWM7d0JBQ2R6QixXQUFXO29CQUNiO2dCQUNGO2dCQUNBLE9BQU87b0JBQ0xyRixJQUFJOEUsU0FBU2lDLEtBQUs7b0JBQ2xCdkUsV0FBV3NDLFNBQVN0QyxTQUFTO29CQUM3QkYsZUFBZXdDLFNBQVN4QyxhQUFhO29CQUNyQ3NFLFlBQVk5QixTQUFTOEIsVUFBVTtvQkFDL0JDLGlCQUFpQi9CLFNBQVMrQixlQUFlO29CQUN6Q3ZELFFBQVF3QixTQUFTeEIsTUFBTTtvQkFDdkJ3RCxjQUFjaEMsU0FBU2dDLFlBQVk7b0JBQ25DekIsV0FBV1AsU0FBU08sU0FBUztnQkFDL0I7WUFDRixHQUNDbkUsSUFBSSxDQUFDLENBQUNDLEdBQUdDLElBQU1ELEVBQUVxQixTQUFTLEdBQUdwQixFQUFFb0IsU0FBUztRQUM3QztJQUNGO0lBRUEsT0FBTztRQUNMZjtRQUNBdUUsUUFBUU87UUFDUmpCLGlCQUFpQlIsU0FBU1EsZUFBZTtRQUN6Q0YsaUJBQWlCTixTQUFTTSxlQUFlO1FBQ3pDQyxXQUFXUCxTQUFTTyxTQUFTO1FBQzdCRyxtQkFBbUJWLFNBQVNVLGlCQUFpQjtRQUM3Q3dCLGtCQUFrQmxDLFNBQVNrQyxnQkFBZ0I7UUFDM0NoRjtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc2VydmljZXMvdWkvb3JkZXJTZXJ2aWNlLnRzPzUwYzciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdjQgYXMgdXVpZHY0IH0gZnJvbSAndXVpZCc7XG5pbXBvcnQgeyBQcm9kdWN0aW9uT3JkZXIsIFByb2R1Y3Rpb25PcmRlclNjaGVtYSwgV29ya0V2ZW50U2NoZW1hLCBPdXRib3hFdmVudFNjaGVtYSwgTG90LCBMb3RTY2hlbWEgfSBmcm9tICcuLi8uLi9zaGFyZWQvc2NoZW1hcyc7XG5pbXBvcnQgeyBQcm9kdWN0aW9uT3JkZXJSZXBvc2l0b3J5RGV4aWUgfSBmcm9tICcuLi8uLi9kYXRhL2RleGllL3dvcmtPcmRlclJlcG9zaXRvcnlEZXhpZSc7XG5pbXBvcnQgeyBFdmVudFJlcG9zaXRvcnlEZXhpZSwgT3V0Ym94UmVwb3NpdG9yeURleGllIH0gZnJvbSAnLi4vLi4vZGF0YS9kZXhpZS9ldmVudFJlcG9zaXRvcnlEZXhpZSc7XG5pbXBvcnQgeyBMb3RSZXBvc2l0b3J5RGV4aWUgfSBmcm9tICcuLi8uLi9kYXRhL2RleGllL2xvdFJlcG9zaXRvcnlEZXhpZSc7XG5pbXBvcnQgeyBQcm9kdWN0UmVwb3NpdG9yeURleGllIH0gZnJvbSAnLi4vLi4vZGF0YS9kZXhpZS9wcm9kdWN0UmVwb3NpdG9yeURleGllJztcbmltcG9ydCB7IE9wZXJhdGlvblJlcG9zaXRvcnlEZXhpZSB9IGZyb20gJy4uLy4uL2RhdGEvZGV4aWUvb3BlcmF0aW9uUmVwb3NpdG9yeURleGllJztcbmltcG9ydCB7IGNvbXB1dGVPcmRlclByb2dyZXNzRnJvbUV2ZW50cywgY29tcHV0ZVN0YWdlVG90YWxzRnJvbUV2ZW50cyB9IGZyb20gJy4uLy4uL2RvbWFpbi9zZXJ2aWNlcy9hZ2dyZWdhdGlvbic7XG5pbXBvcnQgeyBjb21wdXRlTG90UHJvZ3Jlc3NGcm9tRXZlbnRzIH0gZnJvbSAnLi4vLi4vZG9tYWluL3NlcnZpY2VzL2xvdFByb2dyZXNzJztcbmltcG9ydCB7IGZldGNoUHJvZHVjdEJ5SWQgfSBmcm9tICcuL3Byb2R1Y3RTZXJ2aWNlJztcbmltcG9ydCB7IGZldGNoUm91dGluZ1ZlcnNpb25CeUlkLCBmZXRjaFJvdXRpbmdPcGVyYXRpb25zQnlWZXJzaW9uIH0gZnJvbSAnLi9yb3V0aW5nU2VydmljZSc7XG5pbXBvcnQgeyBmZXRjaE9wZXJhdGlvbkJ5SWQgfSBmcm9tICcuL29wZXJhdGlvblNlcnZpY2UnO1xuaW1wb3J0IHsgZ2V0TG90c0Zvck9yZGVyIH0gZnJvbSAnLi9sb3RTZXJ2aWNlJztcblxuY29uc3Qgb3JkZXJSZXBvID0gbmV3IFByb2R1Y3Rpb25PcmRlclJlcG9zaXRvcnlEZXhpZSgpO1xuY29uc3QgZXZlbnRSZXBvID0gbmV3IEV2ZW50UmVwb3NpdG9yeURleGllKCk7XG5jb25zdCBsb3RSZXBvID0gbmV3IExvdFJlcG9zaXRvcnlEZXhpZSgpO1xuY29uc3QgcHJvZHVjdFJlcG8gPSBuZXcgUHJvZHVjdFJlcG9zaXRvcnlEZXhpZSgpO1xuY29uc3Qgb3BlcmF0aW9uUmVwbyA9IG5ldyBPcGVyYXRpb25SZXBvc2l0b3J5RGV4aWUoKTtcblxuZXhwb3J0IHR5cGUgQ3JlYXRlUHJvZHVjdGlvbk9yZGVySW5wdXQgPSB7XG4gIHByb2R1Y3RJZDogc3RyaW5nO1xuICBxdWFudGl0eVJlcXVlc3RlZDogbnVtYmVyO1xuICB0cmFja2luZ01vZGU6ICdwaWVjZScgfCAnbG90JyB8ICdoeWJyaWQnO1xuICBsb3RTaXplPzogbnVtYmVyOyAvLyBSZXF1aXJlZCBpZiB0cmFja2luZ01vZGUgIT0gJ3BpZWNlJ1xuICBub3Rlcz86IHN0cmluZztcbn07XG5cbnR5cGUgUm91dGluZ1NuYXBzaG90T3BlcmF0aW9uID0ge1xuICBvcGVyYXRpb25JZDogc3RyaW5nO1xuICBzZXF1ZW5jZTogbnVtYmVyO1xuICBzdGFuZGFyZE1pbnV0ZXM6IG51bWJlcjsgLy8gUmVxdWlyZWQgZm9yIGFnZ3JlZ2F0aW9uXG4gIG9wZXJhdGlvbk5hbWU/OiBzdHJpbmc7IC8vIE9wdGlvbmFsOiBmb3IgVUkgZGlzcGxheVxuICBxdWFsaXR5R2F0ZT86IGJvb2xlYW47IC8vIE9wdGlvbmFsOiBmb3IgZnV0dXJlIHVzZVxuICB3b3JrQ2VudGVySWQ/OiBzdHJpbmc7IC8vIE9wdGlvbmFsOiBvdmVycmlkZVxufTtcblxudHlwZSBSb3V0aW5nU25hcHNob3QgPSB7XG4gIGlkOiBzdHJpbmc7XG4gIHByb2R1Y3RJZDogc3RyaW5nO1xuICBvcGVyYXRpb25zOiBSb3V0aW5nU25hcHNob3RPcGVyYXRpb25bXTtcbn07XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjcmVhdGVQcm9kdWN0aW9uT3JkZXIoaW5wdXQ6IENyZWF0ZVByb2R1Y3Rpb25PcmRlcklucHV0KTogUHJvbWlzZTxQcm9kdWN0aW9uT3JkZXI+IHtcbiAgLy8gVmFsaWRhdGUgbG90U2l6ZSBpZiB0cmFja2luZ01vZGUgIT0gcGllY2VcbiAgaWYgKGlucHV0LnRyYWNraW5nTW9kZSAhPT0gJ3BpZWNlJyAmJiAoIWlucHV0LmxvdFNpemUgfHwgaW5wdXQubG90U2l6ZSA8PSAwIHx8IGlucHV0LmxvdFNpemUgPiBpbnB1dC5xdWFudGl0eVJlcXVlc3RlZCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0xvdCBzaXplIGlzIHJlcXVpcmVkIGFuZCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGFyZ2V0IHBpZWNlcycpO1xuICB9XG4gIC8vIGEpIEZldGNoIHByb2R1Y3QgYnkgaWRcbiAgY29uc3QgcHJvZHVjdCA9IGF3YWl0IGZldGNoUHJvZHVjdEJ5SWQoaW5wdXQucHJvZHVjdElkKTtcbiAgaWYgKCFwcm9kdWN0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdQcm9kdWN0IG5vdCBmb3VuZCcpO1xuICB9XG5cbiAgLy8gYikgVmFsaWRhdGUgdGhhdCBwcm9kdWN0LmFjdGl2ZVJvdXRpbmdWZXJzaW9uSWQgZXhpc3RzXG4gIGlmICghcHJvZHVjdC5hY3RpdmVSb3V0aW5nVmVyc2lvbklkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdQdWJsaXNoIGEgcm91dGluZyB2ZXJzaW9uIGZpcnN0Jyk7XG4gIH1cblxuICAvLyBjKSBGZXRjaCByb3V0aW5nVmVyc2lvbiBhY3RpdmUgKyByb3V0aW5nT3BlcmF0aW9uc1xuICBjb25zdCByb3V0aW5nVmVyc2lvbiA9IGF3YWl0IGZldGNoUm91dGluZ1ZlcnNpb25CeUlkKHByb2R1Y3QuYWN0aXZlUm91dGluZ1ZlcnNpb25JZCk7XG4gIGlmICghcm91dGluZ1ZlcnNpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0FjdGl2ZSByb3V0aW5nIHZlcnNpb24gbm90IGZvdW5kJyk7XG4gIH1cbiAgaWYgKHJvdXRpbmdWZXJzaW9uLmlzRHJhZnQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0FjdGl2ZSByb3V0aW5nIHZlcnNpb24gaXMgc3RpbGwgYSBkcmFmdC4gUHVibGlzaCBpdCBmaXJzdC4nKTtcbiAgfVxuXG4gIGNvbnN0IHJvdXRpbmdPcGVyYXRpb25zID0gYXdhaXQgZmV0Y2hSb3V0aW5nT3BlcmF0aW9uc0J5VmVyc2lvbihyb3V0aW5nVmVyc2lvbi5pZCk7XG4gIGlmIChyb3V0aW5nT3BlcmF0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0FjdGl2ZSByb3V0aW5nIHZlcnNpb24gaGFzIG5vIG9wZXJhdGlvbnMnKTtcbiAgfVxuXG4gIC8vIGQpIEJ1aWxkIHJvdXRpbmdTbmFwc2hvdCB3aXRoIGZ1bGwgb3BlcmF0aW9uIGRldGFpbHNcbiAgY29uc3Qgb3BlcmF0aW9uc1dpdGhEZXRhaWxzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgcm91dGluZ09wZXJhdGlvbnMubWFwKGFzeW5jIChybykgPT4ge1xuICAgICAgY29uc3Qgb3BlcmF0aW9uID0gYXdhaXQgZmV0Y2hPcGVyYXRpb25CeUlkKHJvLm9wZXJhdGlvbklkKTtcbiAgICAgIGlmICghb3BlcmF0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgT3BlcmF0aW9uICR7cm8ub3BlcmF0aW9uSWR9IG5vdCBmb3VuZGApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBzdGFuZGFyZE1pbnV0ZXMgPSByby5zdGFuZGFyZE1pbnV0ZXNPdmVycmlkZSA/PyBvcGVyYXRpb24uZHVyYXRpb25NaW51dGVzO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBvcGVyYXRpb25JZDogcm8ub3BlcmF0aW9uSWQsXG4gICAgICAgIHNlcXVlbmNlOiByby5zZXF1ZW5jZSxcbiAgICAgICAgc3RhbmRhcmRNaW51dGVzLCAvLyBSZXF1aXJlZCBmb3IgYWdncmVnYXRpb25cbiAgICAgICAgb3BlcmF0aW9uTmFtZTogb3BlcmF0aW9uLm5hbWUsIC8vIE9wdGlvbmFsOiBmb3IgVUkgZGlzcGxheVxuICAgICAgICBxdWFsaXR5R2F0ZTogb3BlcmF0aW9uLnF1YWxpdHlHYXRlID8/IGZhbHNlLCAvLyBPcHRpb25hbDogZm9yIGZ1dHVyZSB1c2VcbiAgICAgICAgd29ya0NlbnRlcklkOiByby53b3JrQ2VudGVySWRPdmVycmlkZSwgLy8gT3B0aW9uYWw6IG92ZXJyaWRlXG4gICAgICB9IGFzIFJvdXRpbmdTbmFwc2hvdE9wZXJhdGlvbjtcbiAgICB9KVxuICApO1xuXG4gIC8vIFNvcnQgYnkgc2VxdWVuY2UgdG8gZW5zdXJlIGNvcnJlY3Qgb3JkZXJcbiAgb3BlcmF0aW9uc1dpdGhEZXRhaWxzLnNvcnQoKGEsIGIpID0+IGEuc2VxdWVuY2UgLSBiLnNlcXVlbmNlKTtcblxuICBjb25zdCByb3V0aW5nU25hcHNob3Q6IFJvdXRpbmdTbmFwc2hvdCA9IHtcbiAgICBpZDogcm91dGluZ1ZlcnNpb24uaWQsXG4gICAgcHJvZHVjdElkOiBwcm9kdWN0LmlkLFxuICAgIG9wZXJhdGlvbnM6IG9wZXJhdGlvbnNXaXRoRGV0YWlscyxcbiAgfTtcblxuICAvLyBlKSBDcmVhdGUgUHJvZHVjdGlvbk9yZGVyXG4gIGNvbnN0IHdvcmtzaG9wSWQgPSB1dWlkdjQoKTsgLy8gR2VuZXJhdGUgbmV3IHdvcmtzaG9wSWQgZm9yIHRoaXMgb3JkZXJcbiAgY29uc3Qgb3JkZXJJZCA9IHV1aWR2NCgpO1xuICBjb25zdCBvcmRlciA9IFByb2R1Y3Rpb25PcmRlclNjaGVtYS5wYXJzZSh7XG4gICAgaWQ6IG9yZGVySWQsXG4gICAgcHJvZHVjdElkOiBpbnB1dC5wcm9kdWN0SWQsXG4gICAgcXVhbnRpdHlSZXF1ZXN0ZWQ6IGlucHV0LnF1YW50aXR5UmVxdWVzdGVkLFxuICAgIHdvcmtzaG9wSWQsXG4gICAgcm91dGluZ1ZlcnNpb25TbmFwc2hvdDogcm91dGluZ1NuYXBzaG90LFxuICAgIHRyYWNraW5nTW9kZTogaW5wdXQudHJhY2tpbmdNb2RlLFxuICB9KTtcblxuICAvLyBmKSBQZXJzaXN0IHZpYSByZXBvc2l0b3J5XG4gIGF3YWl0IG9yZGVyUmVwby5hZGQob3JkZXIpO1xuXG4gIC8vIGcpIENyZWF0ZSBsb3RzIGlmIHRyYWNraW5nTW9kZSAhPSBwaWVjZVxuICBpZiAoaW5wdXQudHJhY2tpbmdNb2RlICE9PSAncGllY2UnICYmIGlucHV0LmxvdFNpemUpIHtcbiAgICBjb25zdCBsb3RDb3VudCA9IE1hdGguY2VpbChpbnB1dC5xdWFudGl0eVJlcXVlc3RlZCAvIGlucHV0LmxvdFNpemUpO1xuICAgIGNvbnN0IGxvdHM6IExvdFtdID0gW107XG4gICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xuXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gbG90Q291bnQ7IGkrKykge1xuICAgICAgY29uc3QgaXNMYXN0TG90ID0gaSA9PT0gbG90Q291bnQ7XG4gICAgICBjb25zdCBwbGFubmVkUGllY2VzID0gaXNMYXN0TG90XG4gICAgICAgID8gaW5wdXQucXVhbnRpdHlSZXF1ZXN0ZWQgLSAobG90Q291bnQgLSAxKSAqIGlucHV0LmxvdFNpemUgLy8gTGFzdCBsb3QgZ2V0cyByZW1haW5kZXJcbiAgICAgICAgOiBpbnB1dC5sb3RTaXplO1xuXG4gICAgICBjb25zdCBsb3QgPSBMb3RTY2hlbWEucGFyc2Uoe1xuICAgICAgICBpZDogdXVpZHY0KCksXG4gICAgICAgIG9yZGVySWQ6IG9yZGVySWQsXG4gICAgICAgIGxvdE51bWJlcjogaSxcbiAgICAgICAgcGxhbm5lZFBpZWNlcyxcbiAgICAgICAgY3JlYXRlZEF0OiBub3csXG4gICAgICB9KTtcbiAgICAgIGxvdHMucHVzaChsb3QpO1xuICAgIH1cblxuICAgIGF3YWl0IGxvdFJlcG8uY3JlYXRlTWFueShsb3RzKTtcbiAgfVxuXG4gIC8vIENyZWF0ZSBpbml0aWFsIFdvcmtFdmVudCAoUHJvZHVjdGlvbk9yZGVyQ3JlYXRlZClcbiAgY29uc3QgZXZlbnQgPSBXb3JrRXZlbnRTY2hlbWEucGFyc2Uoe1xuICAgIGlkOiB1dWlkdjQoKSxcbiAgICB0eXBlOiAnUHJvZHVjdGlvbk9yZGVyQ3JlYXRlZCcsXG4gICAgYWdncmVnYXRlSWQ6IG9yZGVyLmlkLFxuICAgIHdvcmtzaG9wSWQ6IG9yZGVyLndvcmtzaG9wSWQsXG4gICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgcGF5bG9hZDogeyBxdWFudGl0eTogb3JkZXIucXVhbnRpdHlSZXF1ZXN0ZWQgfSxcbiAgICBzY2hlbWFWZXJzaW9uOiAxLFxuICB9KTtcbiAgYXdhaXQgZXZlbnRSZXBvLmFwcGVuZChldmVudCk7XG5cbiAgLy8gRW5xdWV1ZSB0byBvdXRib3hcbiAgY29uc3Qgb3V0Ym94UmVwbyA9IG5ldyBPdXRib3hSZXBvc2l0b3J5RGV4aWUoKTtcbiAgY29uc3Qgb3V0Ym94RXZlbnQgPSBPdXRib3hFdmVudFNjaGVtYS5wYXJzZSh7XG4gICAgLi4uZXZlbnQsXG4gICAgc3RhdHVzOiAncGVuZGluZycgYXMgY29uc3QsXG4gIH0pO1xuICBhd2FpdCBvdXRib3hSZXBvLmVucXVldWUob3V0Ym94RXZlbnQpO1xuXG4gIHJldHVybiBvcmRlcjtcbn1cblxuZXhwb3J0IHR5cGUgT3JkZXJzTGlzdFZNID0ge1xuICBvcmRlcklkOiBzdHJpbmc7XG4gIHByb2R1Y3RJZDogc3RyaW5nO1xuICBwcm9kdWN0TmFtZTogc3RyaW5nO1xuICBwcm9kdWN0U2t1Pzogc3RyaW5nO1xuICB0YXJnZXRQaWVjZXM6IG51bWJlcjtcbiAgY29tcGxldGVkUGllY2VzOiBudW1iZXI7XG4gIHdpcFBpZWNlczogbnVtYmVyO1xuICBwcm9jZXNzZWRQaWVjZXM6IG51bWJlcjtcbiAgc2NyYXBQaWVjZXM6IG51bWJlcjtcbiAgY29tcGxldGlvblBlcmNlbnQ6IG51bWJlcjtcbiAgdHJhY2tpbmdNb2RlOiAncGllY2UnIHwgJ2xvdCcgfCAnaHlicmlkJztcbiAgdXBkYXRlZEF0Pzogc3RyaW5nO1xufTtcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZldGNoT3JkZXJzTGlzdCgpOiBQcm9taXNlPE9yZGVyc0xpc3RWTVtdPiB7XG4gIGNvbnN0IG9yZGVycyA9IGF3YWl0IG9yZGVyUmVwby5saXN0QWxsKCk7XG4gIC8vIE5vdGU6IGN1cnJlbnRseSB3ZSBkb24ndCBoYXZlIG11bHRpLXdvcmtzaG9wIGxpc3Rpbmc7IGxpc3RpbmcgYWxsIG9yZGVycyBmb3IgZGVtbyBwdXJwb3Nlc1xuICBcbiAgLy8gRmV0Y2ggYWxsIHByb2R1Y3RzIGluIG9uZSBiYXRjaCB0byBhdm9pZCBOKzFcbiAgY29uc3QgcHJvZHVjdElkcyA9IFsuLi5uZXcgU2V0KG9yZGVycy5tYXAoKG8pID0+IG8ucHJvZHVjdElkKSldO1xuICBjb25zdCBwcm9kdWN0cyA9IGF3YWl0IFByb21pc2UuYWxsKHByb2R1Y3RJZHMubWFwKChpZCkgPT4gcHJvZHVjdFJlcG8uZ2V0QnlJZChpZCkpKTtcbiAgY29uc3QgcHJvZHVjdE1hcCA9IG5ldyBNYXAocHJvZHVjdHMuZmlsdGVyKChwKTogcCBpcyBOb25OdWxsYWJsZTx0eXBlb2YgcD4gPT4gcCAhPT0gdW5kZWZpbmVkKS5tYXAoKHApID0+IFtwLmlkLCBwXSkpO1xuXG4gIC8vIEJhdGNoIGxvYWQgYWxsIGV2ZW50cyBmb3IgYWxsIG9yZGVycyBpbiBvbmUgcXVlcnkgKGF2b2lkIE4rMSlcbiAgY29uc3Qgb3JkZXJJZHMgPSBvcmRlcnMubWFwKChvKSA9PiBvLmlkKTtcbiAgY29uc3QgYWxsRXZlbnRzID0gYXdhaXQgZXZlbnRSZXBvLmxpc3RCeUFnZ3JlZ2F0ZUlkcyhvcmRlcklkcyk7XG4gIFxuICAvLyBHcm91cCBldmVudHMgYnkgYWdncmVnYXRlSWQgKG9yZGVySWQpXG4gIGNvbnN0IGV2ZW50c0J5T3JkZXJJZCA9IG5ldyBNYXA8c3RyaW5nLCB0eXBlb2YgYWxsRXZlbnRzPigpO1xuICBmb3IgKGNvbnN0IGV2ZW50IG9mIGFsbEV2ZW50cykge1xuICAgIGNvbnN0IGV4aXN0aW5nID0gZXZlbnRzQnlPcmRlcklkLmdldChldmVudC5hZ2dyZWdhdGVJZCkgPz8gW107XG4gICAgZXhpc3RpbmcucHVzaChldmVudCk7XG4gICAgZXZlbnRzQnlPcmRlcklkLnNldChldmVudC5hZ2dyZWdhdGVJZCwgZXhpc3RpbmcpO1xuICB9XG5cbiAgLy8gQ29tcHV0ZSBwcm9ncmVzcyBmb3IgZWFjaCBvcmRlciB1c2luZyBwcmUtbG9hZGVkIGV2ZW50c1xuICBjb25zdCB2bXMgPSBvcmRlcnMubWFwKChvKSA9PiB7XG4gICAgY29uc3QgZXZlbnRzID0gZXZlbnRzQnlPcmRlcklkLmdldChvLmlkKSA/PyBbXTtcbiAgICBjb25zdCBwcm9ncmVzcyA9IGNvbXB1dGVPcmRlclByb2dyZXNzRnJvbUV2ZW50cyh7IGlkOiBvLmlkLCBxdWFudGl0eVJlcXVlc3RlZDogby5xdWFudGl0eVJlcXVlc3RlZCB9LCAoby5yb3V0aW5nVmVyc2lvblNuYXBzaG90IGFzIGFueSkgPz8geyBpZDogJycsIG9wZXJhdGlvbnM6IFtdIH0sIGV2ZW50cyk7XG4gICAgY29uc3QgcHJvZHVjdCA9IHByb2R1Y3RNYXAuZ2V0KG8ucHJvZHVjdElkKTtcbiAgICByZXR1cm4ge1xuICAgICAgb3JkZXJJZDogby5pZCxcbiAgICAgIHByb2R1Y3RJZDogby5wcm9kdWN0SWQsXG4gICAgICBwcm9kdWN0TmFtZTogcHJvZHVjdD8ubmFtZSA/PyBgUHJvZHVjdCAoJHtvLnByb2R1Y3RJZC5zbGljZSgwLCA4KX0uLi4pYCxcbiAgICAgIHByb2R1Y3RTa3U6IHByb2R1Y3Q/LnNrdSxcbiAgICAgIHRhcmdldFBpZWNlczogcHJvZ3Jlc3MudGFyZ2V0UGllY2VzLFxuICAgICAgY29tcGxldGVkUGllY2VzOiBwcm9ncmVzcy5jb21wbGV0ZWRQaWVjZXMsXG4gICAgICB3aXBQaWVjZXM6IHByb2dyZXNzLndpcFBpZWNlcyxcbiAgICAgIHByb2Nlc3NlZFBpZWNlczogcHJvZ3Jlc3MucHJvY2Vzc2VkUGllY2VzLFxuICAgICAgc2NyYXBQaWVjZXM6IHByb2dyZXNzLnNjcmFwUGllY2VzLFxuICAgICAgY29tcGxldGlvblBlcmNlbnQ6IHByb2dyZXNzLmNvbXBsZXRpb25QZXJjZW50LFxuICAgICAgdHJhY2tpbmdNb2RlOiBvLnRyYWNraW5nTW9kZSA/PyAncGllY2UnLCAvLyBEZWZhdWx0IHRvICdwaWVjZScgZm9yIGxlZ2FjeSBvcmRlcnNcbiAgICAgIHVwZGF0ZWRBdDogdW5kZWZpbmVkXG4gICAgfSBhcyBPcmRlcnNMaXN0Vk07XG4gIH0pO1xuICByZXR1cm4gdm1zO1xufVxuXG5leHBvcnQgdHlwZSBPcmRlckRldGFpbFZNID0ge1xuICBvcmRlcjogUHJvZHVjdGlvbk9yZGVyO1xuICBzdGFnZXM6IEFycmF5PHtcbiAgICBvcGVyYXRpb25JZDogc3RyaW5nO1xuICAgIG9wZXJhdGlvbk5hbWU/OiBzdHJpbmc7XG4gICAgc2VxdWVuY2U6IG51bWJlcjtcbiAgICBkb25lUGllY2VzOiBudW1iZXI7XG4gICAgc2NyYXBQaWVjZXM6IG51bWJlcjtcbiAgICBzdGFuZGFyZE1pbnV0ZXNQcm9kdWNlZDogbnVtYmVyO1xuICB9PjtcbiAgcHJvY2Vzc2VkUGllY2VzOiBudW1iZXI7XG4gIGNvbXBsZXRlZFBpZWNlczogbnVtYmVyO1xuICB3aXBQaWVjZXM6IG51bWJlcjtcbiAgY29tcGxldGlvblBlcmNlbnQ6IG51bWJlcjtcbiAgYXZnU3RhZ2VQcm9ncmVzcz86IG51bWJlcjtcbiAgbG90cz86IEFycmF5PHtcbiAgICBpZDogc3RyaW5nO1xuICAgIGxvdE51bWJlcjogbnVtYmVyO1xuICAgIHBsYW5uZWRQaWVjZXM6IG51bWJlcjtcbiAgICBkb25lUGllY2VzOiBudW1iZXI7XG4gICAgcmVtYWluaW5nUGllY2VzOiBudW1iZXI7XG4gICAgc3RhdHVzOiAnbm90X3N0YXJ0ZWQnIHwgJ2luX3Byb2dyZXNzJyB8ICdkb25lJztcbiAgICBvdmVyUHJvZHVjZWQ6IGJvb2xlYW47XG4gICAgd2lwUGllY2VzPzogbnVtYmVyO1xuICB9PjtcbiAgZXJyb3I/OiBzdHJpbmc7IC8vIEZvciBpbnZhbGlkIHNuYXBzaG90IGVycm9yc1xufTtcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZldGNoT3JkZXJEZXRhaWwob3JkZXJJZDogc3RyaW5nKTogUHJvbWlzZTxPcmRlckRldGFpbFZNIHwgbnVsbD4ge1xuICBjb25zdCBvcmRlciA9IGF3YWl0IG9yZGVyUmVwby5nZXRCeUlkKG9yZGVySWQpO1xuICBpZiAoIW9yZGVyKSByZXR1cm4gbnVsbDtcbiAgY29uc3QgZXZlbnRzID0gYXdhaXQgZXZlbnRSZXBvLmxpc3RCeUFnZ3JlZ2F0ZShvcmRlcklkKTtcbiAgXG4gIC8vIFNhZmUtdmFsaWRhdGUgcm91dGluZyBzbmFwc2hvdFxuICBjb25zdCBzbmFwc2hvdFBhcnNlUmVzdWx0ID0gUm91dGluZ1NuYXBzaG90U2NoZW1hLnNhZmVQYXJzZShvcmRlci5yb3V0aW5nVmVyc2lvblNuYXBzaG90KTtcbiAgaWYgKCFzbmFwc2hvdFBhcnNlUmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAvLyBJbnZhbGlkIHNuYXBzaG90IC0gcmV0dXJuIGVycm9yIHN0YXRlIChVSSB3aWxsIGhhbmRsZSBncmFjZWZ1bGx5KVxuICAgIHJldHVybiB7XG4gICAgICBvcmRlcixcbiAgICAgIHN0YWdlczogW10sXG4gICAgICBwcm9jZXNzZWRQaWVjZXM6IDAsXG4gICAgICBjb21wbGV0ZWRQaWVjZXM6IDAsXG4gICAgICB3aXBQaWVjZXM6IDAsXG4gICAgICBjb21wbGV0aW9uUGVyY2VudDogMCxcbiAgICAgIGVycm9yOiAnSW52YWxpZCByb3V0aW5nIHNuYXBzaG90JyxcbiAgICB9IGFzIE9yZGVyRGV0YWlsVk0gJiB7IGVycm9yPzogc3RyaW5nIH07XG4gIH1cbiAgY29uc3Qgcm91dGluZ1NuYXBzaG90ID0gc25hcHNob3RQYXJzZVJlc3VsdC5kYXRhO1xuICBcbiAgLy8gQ29tcHV0ZSBvcmRlciBwcm9ncmVzcyB0byBnZXQgY29ycmVjdCBjb21wbGV0aW9uUGVyY2VudFxuICBjb25zdCBwcm9ncmVzcyA9IGNvbXB1dGVPcmRlclByb2dyZXNzRnJvbUV2ZW50cyhcbiAgICB7IGlkOiBvcmRlci5pZCwgcXVhbnRpdHlSZXF1ZXN0ZWQ6IG9yZGVyLnF1YW50aXR5UmVxdWVzdGVkIH0sXG4gICAgcm91dGluZ1NuYXBzaG90LFxuICAgIGV2ZW50c1xuICApO1xuICBcbiAgY29uc3Qgc3RhZ2VzID0gY29tcHV0ZVN0YWdlVG90YWxzRnJvbUV2ZW50cyhyb3V0aW5nU25hcHNob3QsIGV2ZW50cyk7XG4gIFxuICAvLyBGZXRjaCBvcGVyYXRpb24gbmFtZXMgdG8gZW5yaWNoIHN0YWdlc1xuICBjb25zdCBvcGVyYXRpb25JZHMgPSBbLi4ubmV3IFNldChzdGFnZXMubWFwKChzKSA9PiBzLm9wZXJhdGlvbklkKSldO1xuICBjb25zdCBvcGVyYXRpb25zID0gYXdhaXQgUHJvbWlzZS5hbGwob3BlcmF0aW9uSWRzLm1hcCgoaWQpID0+IG9wZXJhdGlvblJlcG8uZ2V0QnlJZChpZCkpKTtcbiAgY29uc3Qgb3BlcmF0aW9uTWFwID0gbmV3IE1hcChvcGVyYXRpb25zLmZpbHRlcigob3ApOiBvcCBpcyBOb25OdWxsYWJsZTx0eXBlb2Ygb3A+ID0+IG9wICE9PSB1bmRlZmluZWQpLm1hcCgob3ApID0+IFtvcC5pZCwgb3BdKSk7XG5cbiAgY29uc3QgZW5yaWNoZWRTdGFnZXMgPSBzdGFnZXMubWFwKChzdGFnZSkgPT4ge1xuICAgIGNvbnN0IG9wZXJhdGlvbiA9IG9wZXJhdGlvbk1hcC5nZXQoc3RhZ2Uub3BlcmF0aW9uSWQpO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5zdGFnZSxcbiAgICAgIG9wZXJhdGlvbk5hbWU6IG9wZXJhdGlvbj8ubmFtZSxcbiAgICB9O1xuICB9KTtcblxuICAvLyBGZXRjaCBsb3RzIGlmIHRyYWNraW5nTW9kZSAhPSBwaWVjZSBhbmQgY29tcHV0ZSBwcm9ncmVzc1xuICBsZXQgbG90czogT3JkZXJEZXRhaWxWTVsnbG90cyddID0gdW5kZWZpbmVkO1xuICBpZiAob3JkZXIudHJhY2tpbmdNb2RlICYmIG9yZGVyLnRyYWNraW5nTW9kZSAhPT0gJ3BpZWNlJykge1xuICAgIGNvbnN0IG9yZGVyTG90cyA9IGF3YWl0IGdldExvdHNGb3JPcmRlcihvcmRlci5pZCk7XG4gICAgaWYgKG9yZGVyTG90cy5sZW5ndGggPiAwKSB7XG4gICAgICAvLyBCdWlsZCByb3V0aW5nIG9wZXJhdGlvbnMgZnJvbSBzbmFwc2hvdCBmb3IgbG90IHByb2dyZXNzIGNhbGN1bGF0aW9uXG4gICAgICBjb25zdCByb3V0aW5nT3BzID0gcm91dGluZ1NuYXBzaG90Lm9wZXJhdGlvbnMubWFwKChvcDogeyBvcGVyYXRpb25JZDogc3RyaW5nOyBzZXF1ZW5jZTogbnVtYmVyIH0pID0+ICh7XG4gICAgICAgIG9wZXJhdGlvbklkOiBvcC5vcGVyYXRpb25JZCxcbiAgICAgICAgc2VxdWVuY2U6IG9wLnNlcXVlbmNlLFxuICAgICAgfSkpO1xuXG4gICAgICAvLyBDb21wdXRlIGxvdCBwcm9ncmVzcyBmcm9tIGV2ZW50c1xuICAgICAgY29uc3QgbG90UHJvZ3Jlc3NNYXAgPSBjb21wdXRlTG90UHJvZ3Jlc3NGcm9tRXZlbnRzKFxuICAgICAgICBvcmRlckxvdHMubWFwKChsb3QpID0+ICh7XG4gICAgICAgICAgaWQ6IGxvdC5pZCxcbiAgICAgICAgICBsb3ROdW1iZXI6IGxvdC5sb3ROdW1iZXIsXG4gICAgICAgICAgcGxhbm5lZFBpZWNlczogbG90LnBsYW5uZWRQaWVjZXMsXG4gICAgICAgIH0pKSxcbiAgICAgICAgcm91dGluZ09wcyxcbiAgICAgICAgZXZlbnRzXG4gICAgICApO1xuXG4gICAgICAvLyBNYXAgdG8gVk0gZm9ybWF0LCBzb3J0ZWQgYnkgbG90TnVtYmVyXG4gICAgICBsb3RzID0gb3JkZXJMb3RzXG4gICAgICAgIC5tYXAoKGxvdCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHByb2dyZXNzID0gbG90UHJvZ3Jlc3NNYXAuZ2V0KGxvdC5pZCk7XG4gICAgICAgICAgaWYgKCFwcm9ncmVzcykge1xuICAgICAgICAgICAgLy8gRmFsbGJhY2sgaWYgcHJvZ3Jlc3Mgbm90IGZvdW5kIChzaG91bGRuJ3QgaGFwcGVuKVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgaWQ6IGxvdC5pZCxcbiAgICAgICAgICAgICAgbG90TnVtYmVyOiBsb3QubG90TnVtYmVyLFxuICAgICAgICAgICAgICBwbGFubmVkUGllY2VzOiBsb3QucGxhbm5lZFBpZWNlcyxcbiAgICAgICAgICAgICAgZG9uZVBpZWNlczogMCxcbiAgICAgICAgICAgICAgcmVtYWluaW5nUGllY2VzOiBsb3QucGxhbm5lZFBpZWNlcyxcbiAgICAgICAgICAgICAgc3RhdHVzOiAnbm90X3N0YXJ0ZWQnIGFzIGNvbnN0LFxuICAgICAgICAgICAgICBvdmVyUHJvZHVjZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICB3aXBQaWVjZXM6IDAsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaWQ6IHByb2dyZXNzLmxvdElkLFxuICAgICAgICAgICAgbG90TnVtYmVyOiBwcm9ncmVzcy5sb3ROdW1iZXIsXG4gICAgICAgICAgICBwbGFubmVkUGllY2VzOiBwcm9ncmVzcy5wbGFubmVkUGllY2VzLFxuICAgICAgICAgICAgZG9uZVBpZWNlczogcHJvZ3Jlc3MuZG9uZVBpZWNlcyxcbiAgICAgICAgICAgIHJlbWFpbmluZ1BpZWNlczogcHJvZ3Jlc3MucmVtYWluaW5nUGllY2VzLFxuICAgICAgICAgICAgc3RhdHVzOiBwcm9ncmVzcy5zdGF0dXMsXG4gICAgICAgICAgICBvdmVyUHJvZHVjZWQ6IHByb2dyZXNzLm92ZXJQcm9kdWNlZCxcbiAgICAgICAgICAgIHdpcFBpZWNlczogcHJvZ3Jlc3Mud2lwUGllY2VzLFxuICAgICAgICAgIH07XG4gICAgICAgIH0pXG4gICAgICAgIC5zb3J0KChhLCBiKSA9PiBhLmxvdE51bWJlciAtIGIubG90TnVtYmVyKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG9yZGVyLFxuICAgIHN0YWdlczogZW5yaWNoZWRTdGFnZXMsXG4gICAgcHJvY2Vzc2VkUGllY2VzOiBwcm9ncmVzcy5wcm9jZXNzZWRQaWVjZXMsXG4gICAgY29tcGxldGVkUGllY2VzOiBwcm9ncmVzcy5jb21wbGV0ZWRQaWVjZXMsXG4gICAgd2lwUGllY2VzOiBwcm9ncmVzcy53aXBQaWVjZXMsXG4gICAgY29tcGxldGlvblBlcmNlbnQ6IHByb2dyZXNzLmNvbXBsZXRpb25QZXJjZW50LFxuICAgIGF2Z1N0YWdlUHJvZ3Jlc3M6IHByb2dyZXNzLmF2Z1N0YWdlUHJvZ3Jlc3MsXG4gICAgbG90cyxcbiAgfTtcbn1cbiJdLCJuYW1lcyI6WyJ2NCIsInV1aWR2NCIsIlByb2R1Y3Rpb25PcmRlclNjaGVtYSIsIldvcmtFdmVudFNjaGVtYSIsIk91dGJveEV2ZW50U2NoZW1hIiwiTG90U2NoZW1hIiwiUHJvZHVjdGlvbk9yZGVyUmVwb3NpdG9yeURleGllIiwiRXZlbnRSZXBvc2l0b3J5RGV4aWUiLCJPdXRib3hSZXBvc2l0b3J5RGV4aWUiLCJMb3RSZXBvc2l0b3J5RGV4aWUiLCJQcm9kdWN0UmVwb3NpdG9yeURleGllIiwiT3BlcmF0aW9uUmVwb3NpdG9yeURleGllIiwiY29tcHV0ZU9yZGVyUHJvZ3Jlc3NGcm9tRXZlbnRzIiwiY29tcHV0ZVN0YWdlVG90YWxzRnJvbUV2ZW50cyIsImNvbXB1dGVMb3RQcm9ncmVzc0Zyb21FdmVudHMiLCJmZXRjaFByb2R1Y3RCeUlkIiwiZmV0Y2hSb3V0aW5nVmVyc2lvbkJ5SWQiLCJmZXRjaFJvdXRpbmdPcGVyYXRpb25zQnlWZXJzaW9uIiwiZmV0Y2hPcGVyYXRpb25CeUlkIiwiZ2V0TG90c0Zvck9yZGVyIiwib3JkZXJSZXBvIiwiZXZlbnRSZXBvIiwibG90UmVwbyIsInByb2R1Y3RSZXBvIiwib3BlcmF0aW9uUmVwbyIsImNyZWF0ZVByb2R1Y3Rpb25PcmRlciIsImlucHV0IiwidHJhY2tpbmdNb2RlIiwibG90U2l6ZSIsInF1YW50aXR5UmVxdWVzdGVkIiwiRXJyb3IiLCJwcm9kdWN0IiwicHJvZHVjdElkIiwiYWN0aXZlUm91dGluZ1ZlcnNpb25JZCIsInJvdXRpbmdWZXJzaW9uIiwiaXNEcmFmdCIsInJvdXRpbmdPcGVyYXRpb25zIiwiaWQiLCJsZW5ndGgiLCJvcGVyYXRpb25zV2l0aERldGFpbHMiLCJQcm9taXNlIiwiYWxsIiwibWFwIiwicm8iLCJvcGVyYXRpb24iLCJvcGVyYXRpb25JZCIsInN0YW5kYXJkTWludXRlcyIsInN0YW5kYXJkTWludXRlc092ZXJyaWRlIiwiZHVyYXRpb25NaW51dGVzIiwic2VxdWVuY2UiLCJvcGVyYXRpb25OYW1lIiwibmFtZSIsInF1YWxpdHlHYXRlIiwid29ya0NlbnRlcklkIiwid29ya0NlbnRlcklkT3ZlcnJpZGUiLCJzb3J0IiwiYSIsImIiLCJyb3V0aW5nU25hcHNob3QiLCJvcGVyYXRpb25zIiwid29ya3Nob3BJZCIsIm9yZGVySWQiLCJvcmRlciIsInBhcnNlIiwicm91dGluZ1ZlcnNpb25TbmFwc2hvdCIsImFkZCIsImxvdENvdW50IiwiTWF0aCIsImNlaWwiLCJsb3RzIiwibm93IiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwiaSIsImlzTGFzdExvdCIsInBsYW5uZWRQaWVjZXMiLCJsb3QiLCJsb3ROdW1iZXIiLCJjcmVhdGVkQXQiLCJwdXNoIiwiY3JlYXRlTWFueSIsImV2ZW50IiwidHlwZSIsImFnZ3JlZ2F0ZUlkIiwidGltZXN0YW1wIiwicGF5bG9hZCIsInF1YW50aXR5Iiwic2NoZW1hVmVyc2lvbiIsImFwcGVuZCIsIm91dGJveFJlcG8iLCJvdXRib3hFdmVudCIsInN0YXR1cyIsImVucXVldWUiLCJmZXRjaE9yZGVyc0xpc3QiLCJvcmRlcnMiLCJsaXN0QWxsIiwicHJvZHVjdElkcyIsIlNldCIsIm8iLCJwcm9kdWN0cyIsImdldEJ5SWQiLCJwcm9kdWN0TWFwIiwiTWFwIiwiZmlsdGVyIiwicCIsInVuZGVmaW5lZCIsIm9yZGVySWRzIiwiYWxsRXZlbnRzIiwibGlzdEJ5QWdncmVnYXRlSWRzIiwiZXZlbnRzQnlPcmRlcklkIiwiZXhpc3RpbmciLCJnZXQiLCJzZXQiLCJ2bXMiLCJldmVudHMiLCJwcm9ncmVzcyIsInByb2R1Y3ROYW1lIiwic2xpY2UiLCJwcm9kdWN0U2t1Iiwic2t1IiwidGFyZ2V0UGllY2VzIiwiY29tcGxldGVkUGllY2VzIiwid2lwUGllY2VzIiwicHJvY2Vzc2VkUGllY2VzIiwic2NyYXBQaWVjZXMiLCJjb21wbGV0aW9uUGVyY2VudCIsInVwZGF0ZWRBdCIsImZldGNoT3JkZXJEZXRhaWwiLCJsaXN0QnlBZ2dyZWdhdGUiLCJzbmFwc2hvdFBhcnNlUmVzdWx0IiwiUm91dGluZ1NuYXBzaG90U2NoZW1hIiwic2FmZVBhcnNlIiwic3VjY2VzcyIsInN0YWdlcyIsImVycm9yIiwiZGF0YSIsIm9wZXJhdGlvbklkcyIsInMiLCJvcGVyYXRpb25NYXAiLCJvcCIsImVucmljaGVkU3RhZ2VzIiwic3RhZ2UiLCJvcmRlckxvdHMiLCJyb3V0aW5nT3BzIiwibG90UHJvZ3Jlc3NNYXAiLCJkb25lUGllY2VzIiwicmVtYWluaW5nUGllY2VzIiwib3ZlclByb2R1Y2VkIiwibG90SWQiLCJhdmdTdGFnZVByb2dyZXNzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./services/ui/orderService.ts\n"));

/***/ })

});